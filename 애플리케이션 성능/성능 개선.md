### 애플리케이션 성능 측정 지표
1. 처리량(Throughput)
- 애플리케이션이 주어진 시간 동안 처리 가능한 트랜잭션의 수
- 웹 애플리케이션은 시간 당 페이지 수로 표현
2. 응답 시간(Response Time) 
- 사용자 입력이 끝난 후 애플리케이션의 응답 출력이 게시될 때까지의 시간
- 애플리케이션의 경우, 메뉴 클릭시 해당 메뉴가 나타나기까지 걸리는 시간
3. 경과 시간(Turnaround Time)
- 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리한 후 결과의 출력이 완료될 때까지 걸리는 시간
4. 자원 사용률(Resource Usage)
- 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

### 유형별 성능 분석 도구
1. 성능/부하/스트레스(Performance/Load/Stress) 점검 도구 
- 애플리케이션의 성능 점검을 위해 가상의 사용자를 점검 도구 상에서 인위적으로 생성한 뒤, 시스템의 부하나 스트레스를 통해 성능 측정 지표인 처리량, 응답시간, 경과 시간 등을 점검하기 위한 도구.
2. 모니터링(Monitoring) 도구
- 애플리케이션 실행 시 자원 사용량을 확인하고 분석하는 도구
- 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 제공하여, 시스템의 안정적 운영을 지원하는 도구

### 성능 테스트 분석 도구 유형
#### 성능 테스트 도구
1. JMeter
- HTTP, FTP, LDAP 등 다양한 프로토콜을 지원하는 안전성, 확장성, 부하, 기능 테스트 도구
- LDAP(Lightweight Directory Access Protocal)
- TCP/IP 위에 조직화되고 비슷한 특성을 가진 객체들의 모임인 디렉터리 서비스를 조회하고 수정하는 응용 프로토콜
- 크로스 플랫폼(Cross-Platform)
2. LoadUI
- UI를 통해 HTTP, JDBC 등 주요 웹사이트를 대상으로 서버 모니터링을 지원하는 부하 테스트 도구
- 크로스 플랫폼(Cross-Platform)
3. OpenSTA
- HTTP, HTTPS 지원하는 부하 테스트 및 생산품 모니터링 도구
#### 시스템 모니터링 도구
1. Scouter
- 단일 뷰 통합/실시간 모니터링, 튜닝에 최적화된 인프라 통합 모니터링 도구
- 크로스 플랫폼(Cross-Platform)
2. Zabbix
- 웹 기반 서버, 서비스, 애플리케이션 모니터링 도구
- 크로스 플랫폼(Cross-Platform)


### 애플리케이션 성능 저하 원인
- 크게 DB 연결 및 쿼리 실행, 내부적인 요인과 외부적인 요인, 기타 환경 설정이나, 네트워크 등의 문제로 구분할 수 있다.

#### 데이터베이스 과년 성능 저하 원인
- 일반적으로 DB에 연결하기 위해 Connection 객체를 생성하거나 쿼리를 실행하는 애플리케이션 로직에서 성능 저하 또는 장애가 빈번하게 발생한다.
1. 데이터베이스 락(DB Lock)
- 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성 시 발생하는 현상
- 요청한 작업은 Lock의 해제 시까지 대기하거나 타임 아웃됨
2. 불필요한 데이터베이스 배치(DB Fetch)
- 실제 필요한 데이터보다 많은 데이터 요청이 들어올 경우, 응답시간 저하 현상 발생
- 결과 세트에서 마지막 위치로 커서를 옮기는 작업이 빈번한 경우, 응답시간 저하 현상 발생
3. 연결 누수(Connection Leak)
- DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생
4. 부적절한 커넥션 풀 크기(Connection Pool Size)
- 너무 작거나 크게 설정한 경우, 성능 저하 현상이 발생할 가능성이 존재.
5. 확정(Commit) 관련
- 트랜잭션이 확정되지 않고 커넥션 풀에 반환 될 때 성능 저하 가능성 존재
- 잘못 작성된 코드로 인해 불필요한 호가저잉 자주 발생하는 경우 성능 저하 가능성 존재

#### 내부 로직으로 인한 성능 저하 원인
1. 웹 애플리케이션의 인터넷 접속 불량
- 웹 애플리케이션 실행 시 인터넷 접속 불량으로 서버 소캣 쓰기는 지속되나, 클라이언트에서 정상적 읽기가 수행되지 않을 경우 성능 저하 기능 존재
2. 특정 파일의 업로드, 다운로드로 인한 성능 저하
- 대량의 파일을 업로드하거나 다운로드할 경우 처리시간이 길어져 애플리케이션의 성능 저하 가능성 존재
3. 정상적으로 처리되지 않은 오류 처리로 인한 성능 저하
- 오류 처리 로직과 실제 처리 로직 부분을 분리하지 않고 코딩하거나, 예외가 발생할 경우에 제대로 처리하지 않아 행이 걸리는 상황이 발생하여 성능 저하 가능성 존재

#### 외부 호출(HTTP,소켓 통신)에 의한 성능 저하 원인
- 임의의 트랜잭션이 수행되는 동안 외부 트랜잭션이 장시간 수행되거나, 타임아웃이 일어나는 경우 성능 저하 현상이 발생핧 수 있다.

#### 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인
1. 환경 설정으로 인한 성능 저하
- 스레드 풀, 힙 메모리의 크기를 너무 작게 설정하면 Heap Memory Full 현상 발생으로 성능 저하 가능성 존재
2. 네트워크 장비로 인한 성능 저하
- 라우터, L4 스위치 등 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 지연에 따른 데이터 손실 발생 시 애플리케이션의 성능 저하 또는 장애가 발생할 가능성 존재

### 애플리케이션 성능 테스트 케이스 작성
1. 테스트 목표 및 목표값을 설정하여 작성
- 테스트 상황 및 사용자 수, 호출 간격, TPS, 응답 시간 등 목표값을 설정
2. 측정 항목을 기술하여 작성 
- TPS, 응답시간, 시스템 사용률, 거래 성공 비율 등 측정 항목에 대해 기술(TPS란: 초당 처리 건수)
3. 사전 확인 사항 작성
- 테스트 시작 시간, 종료 시간, 스크립트 수행 횟수, 부하 발생기 상태 확인, 데이터베이스 상태 확인,  투입 인력 확인, 테스트 환경 설정, 테스트 데이터 등에 대해 작성

### 애플리케이션 성능 테스트 수행 절차
1. 성능 테스트 도구 설치 : 대상시스템에 선정된 테스트 도구 설치 
2. 테스트 환경 설정 : 해당 시스템의 운영체제, DBMS 버전, 네트워크 상태 등에 대해 설정
3. 시나리오 생성 : 테스트 목적에 맞는 부하 형태, 파라미터, 사용자 수 , Ramp-Up load, 수행 시간, 모니터링 결과 저장 파일 등
- 참고 설명 : Ramp-up load(한계점 측정을 목적으로 낮은 수준의 부하부터 높은 수준의 부하까지 예상 트래픽을 꾸준히 증가시키며 진행하는 부하 테스트)
4. 성능 테스트 및 모니터링  : 성능 테스트를 수행하면서 테스트 상황을 도구를 통해 모니터링

### 소스 코드 최적화의 이해
- 읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것으로, 소스 코드 품질을 위해 기본적으로 준수해야 할 원칙과 기준을 정의하고 있다.

#### 배드 코드의 개념
- 다른 개발자가 로직을 이해하기 어렵게 작성된 코드이다.
- 처리 로직의 제어가 정제되지 않고 서로 얽혀 있는 스파게트 코드, 변수나 메서드에 대한 이름 정의를 알 수 없는 코드, 동일한 처리 로직이 중복되어 작성된 코드 등이 있다.

##### 배드 코드의 사례
1. 외계인 코드(Alien Code) : 아주 오래되거나 참고 문서 또는 개발자가 없어서 유지보수 작업이 아주 어려운 코드
2. 스파게티 코드(Spaghetti Code) 
- 스파게트 코드는 컴퓨터 프로그램의 소스 코드가 복잡하게 얽힌 모습이 스파게티 면발 같다하여 붙여진 이름
- 작동은 정상적으로 하지만, 사람이 코드를 읽으면서 그 코드의 작동을 파악하기는 어려운 코드다.
3. 알 수 없는 변수명
- 변수나 메서드에 대한 이름 정의를 알 수 없는 코드
4. 로직 중복
- 동일한 처리 로직이 중복되어 작성된 코드

#### 배드 코드의 유형
1. 오염 : 비즈니스 기능을 수행하지 못하는 많은 컴포넌트들이 존재
2. 문서 부족 ; 현재 코드와 문서가 일치하지 않고, 수정과 변경을 위한 도메인 지식은 크게 증가하지만 개발자의 지식 부족 초래
3. 의미 없는 이름 : 힘스. 클래스, 컴포넌트, 이름들이 명확한 의미를 갖지 못하거나 실제 작동과 불일치한 경우
4. 높은 결함도 : 클래스와 컴포넌트 간에 데이터와 컨트롤 흐름이  네트워크로 복잡하게 연결
5. 아키텍처 잠식 : 아키텍처가 더 이상 구별되지 않고 여러 솔루션으로 이루어져 아키텍처 상 변형으로 인해 시스템 품질이 떨어짐

### 클린 코드
- 잘 작성되어져 가독성이 높고 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드를 말한다.

### 클린 코드의 특징
- 중복 코드 제거로 애플리케이션의 설계가 개선된다.
- 가독성이 높으므로 애플리케이션의 기능에 대해 쉽게 이해할 수 있다.
- 버그를 찾기 쉬워지며, 프로그래밍 속도가 빨라진다.

### 클린 코드 작성원칙
- 클린코드의 작성 원칙을 준수하고, 베드 코드 형식으로 작성된 소스 코드는 클린 코드로 수정하여 성능을 개선해야 한다.

### 클린코드의 5칙
- 가독성 : 이해하기 쉬운 용어를 사용, 코드 작성 시 들여쓰기 기능 사용
- 단순성 : 한 번에 한 가지 처리만 수행 클래스/메서드/함수를 최소 단위로 분리
- 의존성 최소 : 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성
- 중복성 제거 : 중복된 코드를 제거, 공통된 코드를 사용
- 추상화 : 클래스/메서드/함수에 대해 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스/메서드/함수에서 구현


#### 소스 코드 최적화 기법의 유형
1. 의미 있는 이름
- 변수나 클래스, 메서드 명을 의도가 분명한 이름(사용용도, 작업명)으로 사용
- 클래스는 행위의 주체로 명사나 명사구로 표현하고, 함수 이름은 클래스가 수행하는 행위로 동사 또는 동사구 사용
2. 간결하고 명확한 주서
- 주석이 필요한 경우 최대한 간결하고 명확하게 작성
- 코드 안에 변경이력이나 저자 등의 기록은 형상 관리 도구를 사용
- 코드를 처음 접하는 사람이 궁금한 점에 대해 주석 작성
3. 보기 좋은 배치
- 읽는 사람이 편하게 읽을 수 있도록 구성
- 반복되는 구문은 새로운 하무로 정리하고, 배열을 정리하여 읽기 쉽게 리팩토링
4. 작은 함수
- 함수는 가급적으로 작게 만들고 If 문이나 While 문 안의 내용은 가능한 한 줄로 처리
- 함수 하나 당 하는 일은 하나만 하도록 선언하고 중복이 없도록 작성
5. 읽기 쉬운 제어 흐름
- 조건, 루프, 흐름을 통제하는 선언문이 코드에 있으면 코드가 읽기 어려움
- If/Else 조건 문에서는 인수의 순서는 긍정적이고 간단한 내용을 앞쪽에 배치(부정적인 ! 표현으로 if 작성하면 햇갈린다)
6. 오류 처리
- 오류 코드의 반환보다는 예외처리를 활용
- 메서는 널로 전달하거나 반환하지 말고 널 체크 코드 작성
7. 클래스 분할 배치 
- 클래스는 하나의 역할, 책임만 수행할 수 있도록 응집도를 높이고 크기를 작게 작성
8. 느슨한 결함 기법 사용
- 클래스의 자료 구조, 메서드는 추상화 할 수 있는 인터페이스 클래스를 이용하여 클래스 간의 결함도 최소화 
9. 코드 형식 기법 사용
- 줄 바끔으로 개념을 구분, 종속 함수를 사용, 호출하는 함수를 먼저 배치하고 호출되는 함수를 나중에 배치 
- 변수 선언 위치를 지역 변수는 각 함수 맨 처음에 선언할 때 사용하는 등의 형식 적용


#### 소스 코드 품질분석 개념
- 소스 코드에 대한 코딩 스타일, 설정된 코딩 표준, 코드의 복잡도, 코드 내에 존재하는 메모리 누수 현황, 스레드의 결함 등을 발견하기 위한 활동
- 정적 분석도구와 동적 분석 도구가 있다.

### 소스 코드 분석 도구의 유형 
1. 정적 분석 도구
- 작성된 소스 코들르 실행시키지 않고 코드 자체만으로 코딩 표준 준수 여부, 코딩 스타일 적정 여부, 잔존 결함 발견 여부를 확인하는 코드 분석 도구
2. 동적 분석 도구
- 애플리케이션을 실행하여 코드에 존재하는 메모리 누수 현황을 발견하고, 발생한 스레드의 결함을 분석하는 도구

### 소스 코드 품질분석 도구
#### 정적 분석 도구
1. pmd : 자바 및 타 언어 소스 코드에 대한 버그, 데드코드 분석
2. cppcheck ; c/c++ 코드에 대한 메모리 누수, 오버플로우 등 문제 분석
3. SonarQube : 소스 코드 품질 통합 플랫폼, 플러그인 확장가능
4. ccm : 다양한 언어의 코드 복잡도 분석 도구, 리눅스, 맥 환경 CU 형태 지원
5. cobertura : jcoverage 기반의 테스트 커버리지 측정 도구
#### 동적 분석 도구 
1. Avalanche : Valgrind 프레임워크 및 STP 기반 소프트웨어 에러 및 취약점 동적 분석 도구
2. Valgrind : 자동화된 메모리 및 스레드 결함 발견 분석 도구

## 애플리케이션 성능 개선 방안


### 소스 코드 최적화 기법 적용
- 애플리케이션 개발 프레임워크의 코딩 표준을 설정하고, 인터페이스 클래스를 이용하여 느슨한 결함 코드를 구현한다.
- 인터페이스를 통해 추상화된 자료 구조를 구현하여 의존성을 줄인다.

### 아키텍처 조정으로 통한 성능 개선
- 객체의 생성과 사용을 분리함으로써 소프트웨어의 의존성을 최소화하기 위하여 팩토리 메서드 패턴을 이용하여 성능 개선 방안을 수행한다.

### 프로그램 호출 순서 적용
- 호출하는 함수를 먼저 코딩하고, 호출되는 함수는 나중에 배치하여 애플리케이션의 성능을 개선한다.
- 서로 연관된 내용은 새로로 가깝게 작성함으로써 밀집도를 높이고, 유사성이 높은 함수나 코드끼리 가깝게 배치한다.

#### 호출하는 함수를 먼저 코딩하고, 후출되는 함수는 나중에 배치하는 사례
- 함술르 호출하는 코드를 앞쪽에 배치 
- 실제 코드가 들어있는 함수를 뒤쪽에 배치
- 함수 검색 성능을 높이고 가독성 향상


### 소스 코드 품질 분석 도구 활여ㅛㅇ
1. 메모리 사용 최소화 적용
- String  클래스를 StringBuffer 또는 StringBuilder 클래스로 수정하여 코딩한다.
- 루프 내 불필요한 메서드의 호출이 반복되지 않도록 코딩한다.
2. 입출력 발생 최소화 적용
- 문자 입력 스트림 또는 파일 정보를 읽어올 때 버퍼를 사용하거나 BufferdReader를 사용하여, 입출력 발생 최소화를 통해서 성능을 개선한다.
- 이에 대응하여 Log4j 로거를 사용함으로써 성능을 개선한다.
3. System.out.println에 대한 사용 제외
- 파일, 콘솔에 로그를 남기면 애플리케이션 대기 시간이 발생한다.
- 에에 대응하여 Log4j 로거를 사용함으로써 성능을 개선한다.

#### 리펙토링을 통한 성능 개선
- 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법
- 소프트웨어 모듈의 외보적 기능은 수정하지 않고, 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법

#### 리펙토링의 목적
- 유지 보수성 향상 : 복잡한 코드의 단순화, 소스의 가독성 향상
- 유연한 시스템 : 소프트웨어 요구사항 변경에 유연한 대응
- 생산성 향상 : 정제 및 최적화된 소스의 재사용
- 품질향상 : 소프트웨어 오류 발견이 용이하여 품질향상

