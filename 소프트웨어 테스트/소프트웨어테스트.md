### 소프트웨어 테스트 개념
- 개발된 응용 어플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안전성 등을 만족하는 지 확인하고, 노출되지 않고 숨어있는 소프트웨어 결함을 찾아냄.

### 소프트웨어 테스트 필요성 3가지
1. 오류 발견 관점
- 프로그램에 잠재된 오류를 발견하고 이를 수정하여 올바른 프로그램을 개발하기 위해 필요
2. 오류 예방 관점
- 프로그램 실행 전에 동료 검토 워크 스로, 인스펙션 등을 통해 오류를 사전에 발견하는 예방 차원의 필요
3. 품질 향상 관점
- 사용자의 요구사항 및 기대 수준을 만족하도록 반복적인 테스트를 거쳐 제품의 신뢰도를 향상하는 품질 보증을 위해 필요

### 소프트웨어 테스트의 원리 
1. 결함 존재 증명
- 결함이 존재함을 밝히는 행동
- 결함이 없다는 것을 증명할 수는 없음
- 결함을 줄이는 행동
2. 완벽 테스팅은 불가능
- 완벽하게 테스팅하려는 시도는 불필요한 시간과 자원낭비
- 무한 경로, 무한 입력값으로 인한 테스트 어려움
3. 초기 집중
- 조기 테스트 설계 시 장점 : 테스팅 결과를 단시간에 알 수 있고, 테스팅 기간 단축, 재작업을 줄여 개발 기간 단축 및 결함 예방
- SW 개발  초기 쳬계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 요르돈 법칙 적용(눈덩이 법칙)
4. 결합 집중
- 적은 수의 모듈에서 대다수의 결함이 발견됨
- 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20%에서 발생됨.
- 파레토 법칙의 내용인 80대 20 법칙 적용
5. 살충제 패러독스
- 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
- 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근이 필요
6. 정황 의존성
- 소프트웨어의 성격에 맞게 테스트 실시
- 정황과 비즈니스 도메인에 따라 테스틀 다르게 수행
7. 오류-부재의 궤변
- 요구 사항을 충족시켜주지 못한다면 결함이 없다고 해도 품질이 높다고 볼 수 없다.

### 소프트웨어 테스트 프로세스
1. 테스트 계획
- 테스트 목적과 범위 정의
- 대상 시스템 구조 파악
- 테스트 일정 정의 
- 종료 조건 정의
- 조직 및 비용 산전
2. 테스트 분석 및 디자인
- 테스트 목적과 원칙 검토
- 요구사항 분석
- 리스크 분석 및 우선순위 결정
- 테스트 데이터 준비 
- 테스트 환경 및 도구 준비 
3. 테스트 케이스 및 시나리오 작성
- 테스트 케이스 작성
- 테스트용 스크립트 작성
- 테스트 케이스 검토 및 확인
4. 테스트 수행
- 초기 데이터 로딩
- 테스트 수행
- 결함 리포팅
5. 테스트 결과 평가 및 리포팅
- 테스트 결과 정리
- 테스트 프로세스 리뷰
- 테스트 결과 평가
- 테스트 리포팅

### 소프트웨어 테스트 산출물
1. 테스트 계획서(Test Plan)
- 테스트 목적과 범위 정의, 대상 시스템 구조 파악, 테스트 수행 절차, 테스트 일정, 조직의 역할 및 책임 정의 , 종료 조건 정의 등 테스트 수행을 계획한 문서
2. 테스트 베이시스(Test Basis)
- 분석, 설계 단계의 논리적 Case로 테스트 설계를 위한 기준이 되는 문서(요구사항 명세서, 관련 기준 또는 표준 등)
3. 테스트 케이스(Test Case)
- 테스트를 위한 설계 산출물로 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과로 구성된 테스트.
4. 테스트 슈트(Test Suites)
- 테스트 케이스를 실행 환경에 따라 구분해 놓은 테스트 케이스의 집합
- 시나리오가 포함되지 않은 단순한 테스트 케이스들의 모임
5. 테스트 시나리오(Test Scenario)
- 애플리케이션의 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서
- 하나의 단일 테스트 시나리오가 하나 또는 여러 개의 테스트 케이스들을 포함할 수 있음
- 테스트 시나리오가 테스트 케이스와 일 대 다의 관계를 가짐
6. 테스트 스크립트(Test Script)
- 테스트 케이스의 실행 순서를 작성한 문서
- 테스트 스탭(Test Step), 테스트 절차서(Test Procedure)라고도 함
7. 테스트 결과서(Test Results)
- 테스트 결과를 정리한 문서로 테스트 프로세스를 리뷰하고, 테스트 결과를 평가하고 리포팅하는 문서

### 프로그램 실행 여부에 따른 분류
1. 정적 테스트
- 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트
- 리뷰, 정적 분석
2. 동적 테스트
- 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트
- 화이트박스테스트, 블랙박스 테스트, 경험 기반 테스트

### 테스트 방법에 따른 분류
#### 1. 화이트박스 테스트
![download](https://user-images.githubusercontent.com/72552897/164609340-21df80a3-f3c1-4d7f-a650-f1cbd09e224a.jpg)
- 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 테스트하는 방법
- 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행되고, 산출물의 기능 별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검
- 내부 소스 코드의 동작을 개발자가 추적할 수 있기 때문에 동작의 유효성 뿐만 아니라 실행되는 과정을 확인할 수 있다.
- 화이트박스 테스트는 구조 기반, 코드 기반, 로직 기반, 글래스 박스 테스트라고도 부른다.

##### 화이트 박스 테스트의 종류
1. 구문 카버리지 = 문장 카버리지(Statement Coverage)
- 구문 카버리지는 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 카버리지
- 조건문 결과와 관계 없이 구문 실행 개수로 계산
2. 결정 카버리지 = 선택 카버리지(Decision Coverage) = 분기 카버리지(Branch Coverage)
- 결정 카버리지는 (각 분기의) 결정 포인트 내의 전체 조건식이 적어도 한 번은 참(T)과 거짓(F)의 결과를 수행하는 테스트 커버리지.
- 구문 커버리지를 포함.
3. 조건 커버리지(Condition Coverage)
- 조건 카버리지는 (각 분기의) 결정 포인트 내의 각 개별 조건식도 참 한번, 거짓 한 번 결과가 되도록 수행하는 테스트 커버리지.
4. 조건/결정 커버리지(condition/Decision Coverage)
- 조건/결정 커버리지는 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한번 결과가 되도록 수행하는 테스트 커버리지.
5. 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
- 개별 조건식이 다른 개별 조건식에 여향을 받지 않고, 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지.
6. 다중 조건 커버리지(Multiple Condition Coverage)
- 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지.
7 기본 경로 커버리지 = 경로 커버리지(Base Path Coverage)
- 수행 가능한 모든 경로를 테스트하는 기법
8. 제어 흐름 테스트(Control Flow Testing)
- 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법
9. 데이터 흐름 테스트(Data Flow Testing)
- 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법

-----------------------------------

#### 2. 블랙박스 테스트(Black-Box Test)
- 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트.
- 소프트웨어의 특정, 요구사항, 설게 명세서 등에 초점을 맞춰 테스트가 이뤄진다.
- 기능 및 동작 위주의 테스트를 진행하기 때문에 내부 구조나 작동 원리는 알지 못해도 가능하다.
- 그런 이유로 명세 테스트라고 불린다.


##### 블랙박스 테스트 유형
1. 동등 분할 테스트 = 동치 분할 테스트, 균등 분할 테스트, 동치 클래스 분해 테스트(Equivalence Partitioning Testing)
- 입력 데이터의 영역을 유사한 도메인 별로 유효괎/무효값을 구룹핑 하여 대표값 테스트 케이스를 도출하여 테스트하는 기법
2. 경곗값 분석 테스트 = 한곗값 테스트(Boundary Value Analysis Testing)
- 동기 분할 후 경계값 부분에서 오류 발생 확률이 높기 때문에 경계값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법
- 최솟값 바로 위 최대치 바로 아래 등 입력값의 극한 한계를 테스트한느 기법
3. 결정 테이블 테스트(Decision Table Testing)
- 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행울르 모두 조합하여 테스트하는 기법
4. 상태 전의 테스트(State Transition Testing)
- 테스트 대상 시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전의되는 경우의 수를 수행하는 테스트 기법
5. 유스케이스 테스트(Use Case Testing)
- 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때, 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법
6. 분류 트리 테스트(Classification Tree Method Testing)
- SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
7. 페어와이즈 테스트(Painwise Testing)
- 테스트 데이터 값들 간에 최소한 한 번 씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 선트를 구성하기 위한 테스트 방법
8. 원인-결과 그래프 테스트(Cause-Effect Graph Testing)
- 그래르플 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
9. 비교 테스트(Comparison Testing)
- 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법


### 테스트 시각에 따른 분류
1. 검증(Verification)
- 소프트웨어 개발 과정을 테스트
- 올바른 제품을 생산하고 있는지 검증
- 이전 단계에서 설정된 개발 규격과 요구를 충족시키는지 판단
- 개발자 혹은 시험자의 시각으로 소프트웨어가 명세화된 기능을 올바르게 수행하는지 알아보는 과정
2. 확인(Validation)
- 소프트웨어 결과를 테스트
- 만들어진 제품이 제대로 동작하는지 확인
- 최종 사용자 요구 또는 소프트웨어 요구에 적합한지 판단
- 사용자 시각으로 올바른 소프트웨어가 개발되었는지 입증하는 과정


### 테스트 목적에 따른 분류
1. 회복 테스트(Recovery Testing)
- 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법
2. 안전 테스트(Security Testing)
- 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법
3. 성능 테스트(Performance Testing)
- 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 시용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법
4. 구조 테스트(Structure Testing)
- 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법
5. 회귀 테스트(Regression Testing)
- 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법
6. 병행 테스트(Paralel Testing)
- 변경된 시스템과 기본 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법

### 성능 테스트의 상세 유형
1. 부하 테스트(Load Testing)
- 시스템에 부하를 게속 증가시키면서 시스템의 임계점을 찾는 테스트
- 부하 테스트를 통해 병목 지점을 찾아서 병목 현상을 제거하는 과정을 반복
- 임계점이란? 처리량이 더는 증가하지 않거나 CPU 이용률이나 메모리 사용량이 비정상적으로 증가하는 지점을 일켣는다.
2. 강도 테스트(Stress Testing)
- 시스템 처리 능력 이상의 부하, 즉 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리를 테스트
3. 스파이크 테스트(Spike Testing)
- 짧은 시간에 사용자가 몰릴 떄 시스템의 반응 측정 테스
4. 내구성 테스트(Endurance Testing)
- 짧은 시간에 사용자가 몰릴 떄 시스템의 반응 측정 테스트

### 테스트 종류에 따른 분류
1. 명세 기반 테스트(블렉박스 테스트)
- 프로그램 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트하는 기법
- 동등분할 테스트, 경계값 분석, 결정 테이블 테스트, 상태 전이 테스트, 유스케이스테스트, 분류 트리 테스트, 페어와이즈 테스트, 원인-결과 그래프 테스트, 비교 테스트
2. 구조 기반 테스트(화이트박스 테스트)
- 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트.
- 구문 커버리지, 결정 커버리지, 조건 커버리지, 조건 결정 커버리지, 변경 조건 결정 커버리지, 다중 조건 커버리지, 기본 경로 커버리지, 제어 흐름 테스트, 데이터 흐름 테스트
3. 경험 기반 테스트(블랙박스 테스트)
- 유사 소프트웨어나 유사 기술 평가에서 테스터의 경험을 토대로 한, 직관과 기술 능력을 기반으로 수행하는 테스트 기법
- 탐색적 테스트, 오류 추정

## 정적테스트

### 리뷰(Review)
-소프트웨어의 다양한 산출물에 존재하는 결함을 검출하거나. 프로젝트의 진행 상황을 점검하기 위해 전문가가 수행하는 활동


### 리뷰 프로세스
IEEE1028-2008에서 정의한 리뷰 프로세스는 경영진 준비, 리뷰 계획, 리뷰 절차 개요 설명, 작업물 개요 설명, 개별 준비, 그룹 검토, 재작업, 후속 작업 순으로 이뤄져있다.

### 리뷰의 유형
#### 1. 동료 검토(Peer Review)
- 2~3명이 진행하는 리뷰의 형태로 요구사항 명세서 작성자가 요구사항 명세서를 설명하고, 이해 관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토기법

#### 2. 인스펙션
- 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법이다.
- 개발 초기에 검사해야만 개발 초기 작업물에서 문제를 발견할 수 있다.

##### 인스펙션 프로세스
1. 계획 수립
- 리뷰 리더인 주재자가 리뷰 목적 파악 및 리뷰 팀 구성
- 팀원에게 책임 할당 및 리뷰 참가자들에게 리뷰 날짜, 장소 공지 
- 참가자들에게 인스팩션 필요자료 제공
2. 절차 및 작업물의 개요 설명
- 작성자가 검토자들에게 절차를 설명하고, 이해도를 높이기 위한 검토 작업물에 대한 설명진행
- 이 단계에서는 해결책을 제안하지 않음
3. 준비
- 실제 리뷰 회의 전에 팀 구성원의 작업물 검토
- 준비 기간에 검출된 문제들은 주재자에게 전달
4. 검토회의
- 개별적으로 체크리스트를 사용하며 작업물에 대한 개별 검토가 완료된 후, 모든 검토자가 참가하는 회의 진행
- 참가자들은 객관적으로 철저하게 작업물 검사, 기록자는 검출한 문제 분류 및 관련 정보 기록
5. 재작업
- 검출된 무넺 목록이 작성자에게 전달되면 작성자는 실제 작업물에서 문제를 해결하는 작업 수행
6. 후속작업
- 주재가 발견된 모든 문제에 대해 재작업이 충분하게 완료되었는지 호가인 

#### 3. 워크 스루(Walk Throught)
- 검토 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 기법.
- 결함을 검출할 뿐만 아니라 참가자들의 교육이나 지식 공유를 위해 수행되기도 한다.
- 작성자 본인이 보통 회의를 주재하며 기록자 역할도 담당할 수 있고, 인스펙션과 마찬가지로 관리자 직책을 담당하는 사람은 맴버로 정의하는 것을 금지한다.
- 재작업 및 후속 단계에서 작성자는 모든 조치사항들이 종결되었음을 확인한다.


### 정적 분석(Static Analysis)
- 리뷰는 사람이 직접 수행하는 수작업 중심의 방법이지만 정적 분석은 도구의 지원을 받아 정적 테스트를 수행하는 방법이다.
- 자동화된 도구를 이용하여 산출물의 결함을 검출하거나 복잡도를 측정한다.

#### 정적 분석의 종류
1. 코딩 표준 부합
- 프로그램 작성 시 개발자가 지켜야 할 코딩 표준 및 코딩 지침에 대한 준수 여부 검사
- MISRA-C,MISRA-C++ 등의 코딩 표준에 대한 준수 여부 검사 
- 대표적인 도구로는 LDRA, PRQA, ParaSoft의 제품이 있음
2. 복잡도 측정
- 신뢰할 수 있는 척도를 사용하여 프로그램의 복잡도 측정 및 분석 검사 
- McCabe의 순환 복잡도(Cyclomatic Complexity)의 복잡도 지표가 가장 널리 사용되고 많은 정적 도구가 이 지표를 지원한다.
3. 자료 흐름 분석
- 프로그램의 자료 흐름에 이상 존재 여부에 대한 분석 검사

### 동적 테스트
#### 화이트박스 테스트
- 각 운용 프로그램의 내부 구조와 동적을 검사하는 소프트웨어 테스트다.
- 구조 기반 테스트, 코드 기반 테스트, 로직 기반 테스트, 글래스 박스 테스트

#### 기본적인 개념
- 제어 흐름 그래프는 프로그램 구조를 효과적으로 나타낼 수 있는 도구다
- 화이트 박스 테스트 시에 우선 프로그램을 기본 블록과 제어 흐름으로 구성된 제어 흐름 그래프를 그린 후에 테스트 케이스를 추출한다.
- 가장 좋은 화이트박스 테스트는 프로그램의 모든 경로를 최소한 한 번은 테스트하는 방법이지만, 프로그램 경로가 많기 때문에 불가능에 가깝다.
- 대인으로 일부 경로만 테스트하는 방법을 화이트박스 테스트에서는 사용하고 있다.

#### 테스트 커버리지 개념
- 테스트 커버리지는 프로그램의 테스트 수행 정도를 나타내는 방법으로 테스트 수행의 완벽성을 측정하는 도구이다.
- 테스트 커버리지는 주어진 테스트 케이스에 대해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준이다.
- 테스트의 정확성과 신뢰성을 향상시키는 역할을 한다.
- 시스템 또는 컴포넌트에서 테스트가 수행된 정도를 나타낸다. (얼마나 많은 범위를 테스트했는가?)
- 모든 경로 테스트는 불가능하기에 100% 커버 가능한 테스트는 불가능하다.
- 테스트 커버리지는 코드로 작성된 부분만 측정 가능하고, 특정 기능이 구현되지 않았거나, 명세서의 기능이 생략된 경우 결함 발견이 어렵다.

#### 테스트 커버리지 유형
1. 기능 기반 커버리지
- 테스트 대상 애플리케이션의 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 측정하는 방법
- 100% 달성을 목표로 하며, 일반적으로 UI가 많은 시스템의 경우 화면 수를 모수로 사용한다.
2. 라인 커버리지
- 애플리케이션 전체 소스 코드의 라인 수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인 수를 측정하는 방법
- 단위 테스트에서는 이 라인 커버리지를 척도로 삼음
3. 코드 커버리지
- 소프트웨어 테스트 충분성 지표 중 하나
- 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법
- 일반적으로 테스트 커버리지라고 하면 코드 커버러지를 말한다.

#### 테스트 커버리지의 구성
- 구문(문장 ; Statement), 결정(Decision), 조건(Condition), 결정 포인트(Decision Point)로 구성되어 있다.
- 소스 코드는 구문으로 구성되어 있고, 조건문에 대한 결정이 있고, 결정에 대한 각 조건식이 있다.
- 참과 거짓에 대한 결정 포인트가 있는데, 소스 코드상의 if, while, for, switch 문이 결정 포인트라고 할 수 있다.
- 전체 조건 식은 소스 코드에서 결정 포인트 내에 있는 모든 조건 문이고, 개별 조건 식은 전체 조건식에 연산자(AND,OR 등)로 구분한 각각의 조건식이다.

#### 구문 카버리지(Statement Coverage)
- 구문 커버리지는 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 테스트 커버리지다.
- 구문 커버리지는 조건문 결과와 관계없이 구문 실행 개수로 계산한다.
- 문장 커비리지 = 테스트 케이스 집합에 의해 실행된 문장의 수 / 전체 실행 가능한 프로그램 문장의 수 X 100

#### 결정 커버리지(Decision Coverage)
- 결정 커버리지는 각 분기의 결정 포인트 내 전체 조건식이 적어도 한번은 참과 거짓의 결과를 수행하는 테스트 커버리지이다.
- 결정 커버리지는 선택 커버리지, 분기 커비리지라고도 부른다.
- 결정 커버리지 = 테스트 케이스 집합에 의해 실행된 결과의 수 / 전체 프로그램 결과 수 X 100
- 결정 커비리지는 구문 커버리지를 포함한다.

### 조건 커버리지(Condition Coverage)
- 조건 커버리지는 결정 포인트 내의 개별 조건 식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지다.
- 조건 커버리지 = 텟트 케이스 집합에 의해 실행된 조건의 결과수/전체 프로그램 조건의 결과 수 X 100

### 조건/결정 커버리지(Condition/Decision Coverage)
- 조건 커버리지와 결정 커버리지를 최소한의 조합으로 달성하는 커버러지다.
- 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한번 결과가 되도록 수행하는 커버리지다.
- 조건/결정 커버리지= (테스트 케이스 집합에 의해 실행된 조건/결정의 결과수) / (전체 프로그램 조건/결과의 결과 수) X 100

### 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
-  각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고, 전체 조건식의 결과에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시키는 커버리지다.
-  변경 조건 결정 커버리지가 조건 결정 커비리지와 다른 점은 결정을 구성한는 각 조건이 독립적으로 결정의 결과에 양향을 미쳐야 한다는 것이다.
-  즉, 각 조건이 결정을 구성하는 다른 조건들과는 무관하게 전체 결정의 평가에 양향을 미치는지를 알아보기 위한 테스트 케이스를 생성해야 한다.
-  변경 조건/결정 커버리지= 텟트ㅡ 케이스 집합에 의해 MC/DC를 만족하는 조건의 개수/ 총 조건의 개수 X 100

### 다중 조건 커버리지(Multiple Condition Coverage)
- 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 테스트 커버리지다.
- 각 조건문 내 기본 조건식의 가능한 논리적인 조합이 적어도 한 번은 테스트되도록 테스트 케이스를 도출하는 방버이다.
- 다중 조건 커버리지는 문장 커버리지, 결정 커버리지, 조건 커버리지 및 조건/결정 커버리지를 포용한다.

### 기본 경로 커버리지
- 기본 경로 커버리지는 맥케이브의 순환복잡도를 기반으로 커버리지를 계산한다.

#### 맥케이브의 순환 복잡도 개념
- 순환 복잡도 측정방식은 제어 흐름에 의한 그래프를 통하여 원시 코드의 회전수를 구하여 복잡도를 계산한다.

#### 맥케이브의 순환 복잡도 측정 방법
![tempsnip](https://user-images.githubusercontent.com/72552897/164845484-b84a4ddc-d17d-44ee-8bbd-c74c2e48eb61.png)

#### 기본 경로 커버리지(Base Path Coverage) 개념
- 수행 가능한 모든 경로를 테스트하는 기법
- 기본 경로 집합을 식별하여, 기본 경로들을 실행할 수 있는 테스트 데이터를 생성하고 테스트하는 기법
- 기본 경로 커버리지는 경로 커버리지라고도 함
- McCabe가 제안한 테스트 방법으로 순한 복잡도에 근거한 테스트 법이다.
- 순환 복잡도는 소프트웨어 복잡도에 대한 정량적 지표이고, 프로그램의 기본 경로수는 해당 프로그램의 순환 복잡도와 같다.

#### 기본 경로 커버리지 방법
- 식별한 모든 기본 경로 중 테스트를 수행한 기본 경로의 비율로 게산
- (테스트를 수행한 기본 경로의 비율)/(식별한 모든 경로의 수) X 100

### 제어 흐름 테스트(Control Flow Testing)
- 프로그램 제어 구조를 그래프 형태로 나타내어 내부 조직을 테스트하는 기법
- 제어 흐름 테스트는 프로그램의 제어 구조를 충분히 커버하도록 경로를 선택함으로써 테스트 케이스가 개발되며, 선택된 경로들은 '테스팅 완전성(Testing Thoroughness)'를 가늠하는 척도가 된다.
- 프로그램의 제어 구조를 그래픽으로 표현한 제어 흐름 그래프를 이용한다.
- 제어 흐름 그래프는 노드들의 집합 N과 에지들의 집합 E로 구성된다. 즉 G(N,E)다.
- 제어 흐름 레벨에 따라 테스트 강도 조절이 가능하다.

### 제어 흐름 테스트의 수행 절차
1. 테스트 입력 데이터 준비
- 제어 흐름 그래프의 입구 노드에서부터 출구 노드까지 완전한 경로가 하나의 테스트 케이스가 됨
- 즉 해당 경로가 실행되도록 테스트 입력 데이터 준비
2. 테스트 목표 설정 및 테스트 경로 선택
- 작은 프로그램 루틴에도 입구에서 출구까지 수많은 경로가 존재할 수 있음
- 따라서 특정한 '경로 선택 기준'을 테스트 목표로 세우고, 그에 따라 테스트 경로들을 선택함
-

### 블랙박스 테스트(명세 기반 테스트)
- 블랙박스 테스트는 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트다.
- 블랙박스 테스트는 곧 명세 테스트다.
- 모든 종류의 소프트웨어 시스템에 대해 테스트가 가능하다.
- 전체 소프트웨어 테스트 레벨(단위, 통합, 시스템, 인수)에서 적용할 수 잇는 기법.

#### 동등분할 테스트(Equivalence Partitioning Testing)
- 동등 분할 테스트는 입력 데이터의 영역을 유사한 도메인 별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법이다.
- 등등 분할 테스트는 동치 분할, 균등 분할, 동치 클래스 분해 테스트라고도 한다.

#### 경곗값 분석 테스트
- 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법.
- 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트 하는 기법
- 한곗값 테스트라고도 불림
- 경곗값 : 클래스 간의 경곗값, 경계 바로 위 값, 경계 바로 아래 값
- 다수의 오류들이 입력 영역의 경계에서 발생
- 대부분 동등 분할 테스트와 함꼐 사용


##### 경곗값 선택 기준
1. 값의 범위
- 법위의 끝에 속하는 유효 입력값, 범위 바로 바깥에 속하는 유효하지 않은 입력값
2. 몇 개의 값
- 입력값의 최솟값과 최댓값
3. 파일, 리스트, 테이블과 같은 정렬된 집합 형태
- 첫번째 항목과 마지막 항목
4. 그 외
- 개인의 독창성과 직관에 따라 경계에 해당하는 여러 값 선택

##### 경곗값 선택 방법
1. 2-Value
- 경계에 있는 값
- 바로 위, 아래 중 하나의 값
- 경계가 유효하면 유효하지 않은 값, 유효하지 않으면 유효한 값 선택
2. 3-Value
- 경계에 있는 값
- 경계 바로 아래 값
- 경게 바로 위 값


### 결정 테이블 테스트(Decision Table Testing)
- 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법이다.
- 입력 조건의 모든 조합에 대한 시스템의 액션을 고려하여 테스트 케이슬르 도출하는 기법
- 특징으로는 복합한 논리적 관계를 표현하기 좋고, 누락된 요구사항 검사에 용이하다.


#### 결정 테이블 케이스의 테스트 케이스 작성 방법
1. 명세 등을 분석하여 시스템의 행동에 영향을 주는 모든 조건을 분석
2. 조건은 왼쪽 키, 행동은 왼쪽 아래 위치하는 테이블 구성
3. 모든 조건의 조합을 나열하고, 그에 해당하는 행동 작성
4. 가능하지 못한 조건의 조합은 배제
5. 결정표를 축약할 수 있는지 파악
6. 결정표의 각 규칙이 최소한 한 번은 테스트 할 수 있도록 테스트 케이스 생성

### 상태 전이 테스트(State Transition Testing)
- 테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법을 말한다.
- 시스템을 상태 전이도로 모델링 한 후, 상태 전이도에서 테스트 케이스를 도출하는 기법.
- 상태 전이도는 시스템 외부에서 들어오는 일련의 이벤트 들에 대해 시스템 상태가 어떻게 전이도고 어떤 식으로 반응하는가를 나타내는 도구다.

### 상태 전이도 사례
![download](https://user-images.githubusercontent.com/72552897/164861687-cad54cc3-a964-4182-9511-deaf5e23ee7a.jpg)

### 유스케이스 테스트(Use Case Testing)
- 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때, 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스를 말한다.

### 분류 트리 테스트(Classification Tree Method Testing)
- SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
- 시스템 또는 SW의 입력 및 동작을 다양한 기준으로 구분한 트리를 이용해서 테스트 케이스를 설계한다.
- 동등 분할 영역을 구분하는 것과 유사하며, 동등 분할 테스트 커버리지 측정 원리와 동일하다.


### 페어 와이즈 테스트
- 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법이다.
- 대부분의 결함이 두 입력값의 상호 작용에 기인하므로 가능한 모든 입력값의 조합을 테스트한 것과 비슷한 효과를 얻는다.
- 상대적으로 적은 량의 테스트 세트 구성에 용이하고, 입력 변수 개수와 입력 가능 값이 많을 수록 테스트 케이스 도출 복잡도가 높아진다.

### 경험 기반 테스트
- 유사 소프트웨어나 유사 기술 평가에서 테스터의 경험을 토대로 한, 직관과 기술 능력을 기반으로 수행하는 테스트 기법이다.
- 경험 기반 테스트의 유형에는 탐색적 테스트, 오류 추정이 있다.

#### 경험 기반 테스트 유형
1. 탐색적 테스트(Exploratory Test)
- 테스트 스크립트 또는 테스트 케이스를 문서로 작성하지 않고, 경험에 바탕을 두고 탐색적으로 기능을 수행해 보면서 테스트하는 기법을 말한다.
- 시잔에 구체적으로 테스트 케이스를 설계하고, 이를 바탕으로 테스트를 수행하는 방식이 아니라, 테스트 대상에 대한 이해, 테스트 케이스 설계, 테스트 실행을 병행하는 방식
- 무작위 테스팅이 아닌 중대한 테스트 위주, 테스트 엔지니어의 휴리스틱한 능력 필요, 제품을 익히면서 테스트를 설계하고 테스트를 수행한다.
- 구성 요소는 테스트 차터, 시간 제한, 노트, 회고 등이 있다.
2. 오류 추정(Error Guessing)
- 개발자가 범할 수 있는 실수를 추정하고, 이에 따른 결함이 검출되도록 테스트 케이스를 설계하여 테스트하는 기법
- 특정 테스트 대상이 주어지면 테스터의 경험과 직관을 바탕으로 개발자가 범할 수 있는 실수들을 나열하고, 해당 실수에 따른 결함을 노출하는 테스트 수행.
- 동등 분할이나 경곗값 분석 같은 명세 기반 테스트 방법과 함께 사용 가능
- 다른 기법이나 공식적인 테스트를 보완할 떄 유용
- 오류 추정은 일반적으로 예상되지 않은 상황이 사용자 입력값으로 적절히 처리되고 있는지를 확인할 떄 유용함
- 
#### 휴리스틱(Heuristics)
- 경험에 기반하여 문제를 해결하거나 학습하거나 발견해내는 방법

#### 테스트 차터(Test Charter)
- 수행될 각 테스트 세션에 대해 명확한 임무를 설정해 놓은 명령지

#### 회고(Debriefing)
- 탐색적 테스팅 세션 종료 후 팀원끼리 요약보고 시간을 갖고 테스트 수행 과정과 경험을 팀원과 공유하는 보고 회의다.




